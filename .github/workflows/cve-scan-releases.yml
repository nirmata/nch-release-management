name: CVE Scan - Releases

on:
  schedule:
    # Run at 2:00 AM PST (10:00 AM UTC during standard time, 9:00 AM UTC during daylight time)
    # Using 10:00 AM UTC to cover PST standard time
    - cron: '0 10 * * *'
  workflow_dispatch:
    inputs:
      release_filter:
        description: 'Specific release to scan (e.g., nch-4.22.11). Leave empty to scan all releases.'
        required: false
        type: string

# Add permissions for accessing packages and writing to repository
permissions:
  contents: write          # For committing scan results
  packages: read           # For accessing private packages in GHCR
  actions: read            # For workflow execution
  id-token: write          # For OIDC token if needed

jobs:
  discover-releases:
    runs-on: ubuntu-latest
    outputs:
      releases: ${{ steps.find-releases.outputs.releases }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Find release directories
        id: find-releases
        run: |
          if [ -n "${{ github.event.inputs.release_filter }}" ]; then
            # If a specific release is requested, only scan that one
            if [ -d "cve-management/releases/${{ github.event.inputs.release_filter }}" ]; then
              releases='["${{ github.event.inputs.release_filter }}"]'
            else
              echo "::error::Release ${{ github.event.inputs.release_filter }} not found"
              exit 1
            fi
          else
            # Find all release directories
            releases=$(find cve-management/releases -maxdepth 1 -type d -name "nch-*" | sed 's|cve-management/releases/||' | jq -R -s -c 'split("\n")[:-1]')
          fi
          echo "releases=$releases" >> $GITHUB_OUTPUT
          echo "Found releases: $releases"

  cve-scan:
    runs-on: ubuntu-latest
    needs: discover-releases
    if: needs.discover-releases.outputs.releases != '[]'
    strategy:
      matrix:
        release: ${{ fromJson(needs.discover-releases.outputs.releases) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # The username can still be the github.actor
          username: ${{ github.actor }}
          # Use the organization-level secret for the password
          password: ${{ secrets.DEPLOYMENT_PAT }}
          
      - name: Install Grype
        run: |
          echo "Installing Grype vulnerability scanner..."
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype version
          
      - name: Verify Docker authentication
        run: |
          echo "Verifying Docker authentication to ghcr.io..."
          echo "GitHub Actor: ${{ github.actor }}"
          echo "Release: ${{ matrix.release }}"
          
          # Test authentication
          echo "Testing GHCR access..."
          if docker manifest inspect ghcr.io/nirmata/users:latest > /dev/null 2>&1; then
            echo "‚úÖ Authentication test successful"
          else
            echo "‚ö†Ô∏è Authentication test failed for latest tag, proceeding with release-specific images"
          fi
          
      - name: Read release images
        id: release-info
        run: |
          release_dir="cve-management/releases/${{ matrix.release }}"
          images_file="$release_dir/images.config"
          
          if [ ! -f "$images_file" ]; then
            echo "::error::images.config file not found for release ${{ matrix.release }}"
            exit 1
          fi
          
          # Count images
          image_count=$(wc -l < "$images_file")
          echo "image_count=$image_count" >> $GITHUB_OUTPUT
          echo "Found $image_count images to scan for release ${{ matrix.release }}"
          
          # Display images
          echo "Images to scan:"
          cat "$images_file"
          
      - name: Create scan results directory
        run: |
          mkdir -p cve-management/releases/${{ matrix.release }}/scan-results
          
      - name: Create SLA analysis script
        run: |
          cat > sla-analysis.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          results_dir="$1"
          release="$2"
          run_id="$3"
          
          echo "========================================================"
          echo "Generating SLA Report for release $release"
          echo "========================================================"
          
          # Load SLA configuration
          sla_config_file="cve-management/sla.config"
          if [ ! -f "$sla_config_file" ]; then
            echo "‚ö†Ô∏è SLA configuration file not found: $sla_config_file"
            exit 0
          fi
          
          echo "üìã Loading SLA configuration from $sla_config_file"
          
          # Load customer list for this release
          customers_file="cve-management/releases/$release/customers.config"
          if [ -f "$customers_file" ]; then
            echo "üë• Loading customer list from $customers_file"
            # Read customers and convert to JSON array, filtering out empty lines
            customers_json=$(grep -v '^[[:space:]]*$' "$customers_file" | jq -R . | jq -s .)
            customer_count=$(echo "$customers_json" | jq 'length')
            customer_list=$(echo "$customers_json" | jq -r '.[]' | tr '\n' ', ' | sed 's/,$//')
            echo "üë• Found $customer_count customers: $customer_list"
          else
            echo "‚ö†Ô∏è Customer list not found: $customers_file"
            customers_json="[]"
          fi
          
          # Create SLA report
          sla_report_file="$results_dir/sla-compliance-report-grype.json"
          
          # Initialize SLA report structure with customers
          cat > "$sla_report_file" << EOJ
          {
            "slaInfo": {
              "reportDate": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
              "release": "$release",
              "workflowRun": "$run_id",
              "impactedCustomers": $customers_json
            },
            "blackList": [],
            "redList": [],
            "orangeList": [],
            "yellowList": []
          }
          EOJ
          
          # Parse scan results and categorize CVEs
          if [ ! -f "$results_dir/scan-grype.json" ]; then
            echo "‚ö†Ô∏è No scan results found, skipping SLA report generation"
            exit 0
          fi
          
          echo "üîç Analyzing vulnerabilities for SLA compliance..."
          
          # Create temporary files for each category
          black_temp=$(mktemp)
          red_temp=$(mktemp)
          orange_temp=$(mktemp)
          yellow_temp=$(mktemp)
          
          current_date=$(date +%s)
          
          # Process each image in the scan results
          jq -c '.images[]' "$results_dir/scan-grype.json" | while read -r image_data; do
            image_name=$(echo "$image_data" | jq -r '.image')
            echo "  Analyzing image: $image_name"
            
            # Process each vulnerability in the image
            echo "$image_data" | jq -c '.scan.vulnerabilities[]?' | while read -r vuln; do
              vuln_id=$(echo "$vuln" | jq -r '.vulnerability')
              severity=$(echo "$vuln" | jq -r '.severity')
              fixed_in=$(echo "$vuln" | jq -r '.fixed_in')
              published_date=$(echo "$vuln" | jq -r '.published_date')
              
              # Only process CVEs and GHSAs with fixes available
              if [[ "$vuln_id" == CVE-* || "$vuln_id" == GHSA-* ]] && [ "$fixed_in" != "" ] && [ "$fixed_in" != "null" ]; then
                echo "    Processing: $vuln_id ($severity) - Fix: $fixed_in - Published: $published_date"
                
                # Get SLA days for this severity (convert to lowercase)
                severity_lower=$(echo "$severity" | tr '[:upper:]' '[:lower:]')
                sla_days=$(grep -i "^${severity_lower}," "$sla_config_file" | cut -d',' -f2 || echo "")
                
                if [ -n "$sla_days" ] && [ "$published_date" != "N/A" ] && [[ "$published_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                  # Calculate days since publication (cross-platform compatible)
                  if date -d "$published_date" +%s >/dev/null 2>&1; then
                    # GNU date (Linux)
                    published_epoch=$(date -d "$published_date" +%s)
                  else
                    # BSD date (macOS)
                    published_epoch=$(date -j -f "%Y-%m-%d" "$published_date" +%s)
                  fi
                  
                  days_elapsed=$(( (current_date - published_epoch) / 86400 ))
                  days_remaining=$(( sla_days - days_elapsed ))
                  
                  echo "      SLA: $sla_days days, Elapsed: $days_elapsed days, Remaining: $days_remaining days"
                  
                  # Create vulnerability entry
                  vuln_entry=$(jq -n \
                    --arg vuln_id "$vuln_id" \
                    --arg severity "$severity" \
                    --arg published_date "$published_date" \
                    --arg fixed_in "$fixed_in" \
                    --arg image "$image_name" \
                    --argjson days_elapsed "$days_elapsed" \
                    --argjson days_remaining "$days_remaining" \
                    --argjson sla_days "$sla_days" \
                    '{
                      vulnerability: $vuln_id,
                      severity: $severity,
                      publishedDate: $published_date,
                      fixedIn: $fixed_in,
                      daysElapsed: $days_elapsed,
                      daysRemaining: $days_remaining,
                      slaDays: $sla_days,
                      images: [$image]
                    }')
                  
                  # Categorize based on days remaining
                  if [ "$days_remaining" -lt 0 ]; then
                    echo "$vuln_entry" >> "$black_temp"
                    echo "      ‚Üí BLACK LIST (SLA exceeded by $((-days_remaining)) days)"
                  elif [ "$days_remaining" -le 7 ]; then
                    echo "$vuln_entry" >> "$red_temp"
                    echo "      ‚Üí RED LIST ($days_remaining days remaining)"
                  elif [ "$days_remaining" -le 21 ]; then
                    echo "$vuln_entry" >> "$orange_temp"
                    echo "      ‚Üí ORANGE LIST ($days_remaining days remaining)"
                  else
                    echo "$vuln_entry" >> "$yellow_temp"
                    echo "      ‚Üí YELLOW LIST ($days_remaining days remaining)"
                  fi
                else
                  if [ -z "$sla_days" ]; then
                    echo "      ‚ö†Ô∏è Skipped: No SLA found for severity '$severity'"
                  elif [ "$published_date" = "N/A" ] || [[ ! "$published_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                    echo "      ‚ö†Ô∏è Skipped: Invalid or unavailable published date '$published_date'"
                  fi
                fi
              fi
            done
          done
          
          echo "‚úÖ SLA analysis complete"
          echo "üìä Generating consolidated SLA report..."
          
          # Consolidate duplicate CVEs across images and rebuild the report
          for category in black red orange yellow; do
            temp_file_var="${category}_temp"
            temp_file="${!temp_file_var}"
            
            if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
              # Group by vulnerability ID and merge images
              consolidated=$(jq -s '
                group_by(.vulnerability) | 
                map({
                  vulnerability: .[0].vulnerability,
                  severity: .[0].severity,
                  publishedDate: .[0].publishedDate,
                  fixedIn: .[0].fixedIn,
                  daysElapsed: .[0].daysElapsed,
                  daysRemaining: .[0].daysRemaining,
                  slaDays: .[0].slaDays,
                  images: (map(.images[]) | unique)
                })
              ' "$temp_file")
              
              # Update the SLA report with this category
              jq --argjson data "$consolidated" ".${category}List = \$data" "$sla_report_file" > "${sla_report_file}.tmp"
              mv "${sla_report_file}.tmp" "$sla_report_file"
            fi
            
            # Cleanup temp file
            rm -f "$temp_file"
          done
          
          echo "‚úÖ SLA report generated: $sla_report_file"
          
          # Display summary
          black_count=$(jq '.blackList | length' "$sla_report_file")
          red_count=$(jq '.redList | length' "$sla_report_file")
          orange_count=$(jq '.orangeList | length' "$sla_report_file")
          yellow_count=$(jq '.yellowList | length' "$sla_report_file")
          
          echo ""
          echo "üìä SLA Report Summary:"
          echo "üî¥ BLACK (SLA Exceeded): $black_count CVEs"
          echo "üî¥ RED (1-7 days left): $red_count CVEs"
          echo "üü† ORANGE (8-21 days left): $orange_count CVEs"
          echo "üü° YELLOW (>21 days left): $yellow_count CVEs"
          
          # Generate markdown report
          echo "üìÑ Generating SLA markdown report..."
          sla_md_file="$results_dir/sla-compliance-report-grype.md"
          
          # Extract report info
          report_date=$(jq -r '.slaInfo.reportDate' "$sla_report_file")
          workflow_run=$(jq -r '.slaInfo.workflowRun' "$sla_report_file")
          impacted_customers=$(jq -r '.slaInfo.impactedCustomers[]?' "$sla_report_file" | tr '\n' ', ' | sed 's/,$//')
          customer_count=$(jq '.slaInfo.impactedCustomers | length' "$sla_report_file")
          
          # Create markdown header
          cat > "$sla_md_file" << EOM
          # SLA Compliance Report for $release
          
          **Generated**: $report_date  
          **Release**: $release  
          **Workflow Run**: [$workflow_run](https://github.com/nirmata/nch-release-management/actions/runs/$workflow_run)  
          **Impacted Customers**: $customer_count ($impacted_customers)
          
          ## Executive Summary
          
          | Priority | Count | Status |
          |----------|--------|---------|
          | ‚ö´ **BLACK** (Overdue) | $black_count | SLA Exceeded |
          | üî¥ **RED** (Critical) | $red_count | 1-7 days remaining |
          | üü† **ORANGE** (Warning) | $orange_count | 8-21 days remaining |
          | üü° **YELLOW** (Monitor) | $yellow_count | >21 days remaining |
          | **TOTAL** | $((black_count + red_count + orange_count + yellow_count)) | Vulnerabilities with fixes |
          
          ## Customer Impact Analysis
          
          **Release $release affects $customer_count customer(s):**
          EOM
          
          # Add customer list to markdown
          if [ "$customer_count" -gt 0 ]; then
            jq -r '.slaInfo.impactedCustomers[] | "- **\(.)**"' "$sla_report_file" >> "$sla_md_file"
          else
            echo "- *No customers identified for this release*" >> "$sla_md_file"
          fi
          
          cat >> "$sla_md_file" << EOM
          
          **Business Impact**: All vulnerabilities listed below directly affect the security posture of the above customers. Priority should be given to vulnerabilities in the BLACK and RED categories to minimize customer risk exposure.
          
          EOM
          
          # Generate detailed sections for each priority level
          for priority in black red orange yellow; do
            case $priority in
              black) 
                title="‚ö´ BLACK LIST - SLA Exceeded (IMMEDIATE ACTION REQUIRED)"
                description="These vulnerabilities have exceeded their SLA timeframes and require immediate attention."
                ;;
              red)
                title="üî¥ RED LIST - Critical Priority (1-7 days remaining)"
                description="These vulnerabilities are approaching their SLA deadline and need urgent action."
                ;;
              orange)
                title="üü† ORANGE LIST - Warning Priority (8-21 days remaining)"
                description="These vulnerabilities should be planned for remediation in the near term."
                ;;
              yellow)
                title="üü° YELLOW LIST - Monitor Priority (>21 days remaining)"
                description="These vulnerabilities are within SLA but should be monitored for planning purposes."
                ;;
            esac
            
            count=$(jq ".${priority}List | length" "$sla_report_file")
            
            echo "" >> "$sla_md_file"
            echo "## $title" >> "$sla_md_file"
            echo "" >> "$sla_md_file"
            echo "$description" >> "$sla_md_file"
            echo "" >> "$sla_md_file"
            
            if [ "$count" -gt 0 ]; then
              echo "**Count**: $count vulnerabilities" >> "$sla_md_file"
              echo "" >> "$sla_md_file"
              echo "| Vulnerability | Severity | Published | Fix Available | Days Elapsed | Days Remaining | SLA | Affected Images |" >> "$sla_md_file"
              echo "|---------------|----------|-----------|---------------|--------------|----------------|-----|-----------------|" >> "$sla_md_file"
              
              # Extract vulnerabilities for this priority level
              jq -r ".${priority}List[] | 
                \"| [\(.vulnerability)](https://nvd.nist.gov/vuln/detail/\(.vulnerability)) | \(.severity) | \(.publishedDate) | \(.fixedIn) | \(.daysElapsed) | \(.daysRemaining) | \(.slaDays) days | \(.images | join(\", \")) |\"" \
                "$sla_report_file" >> "$sla_md_file"
            else
              echo "‚úÖ **No vulnerabilities in this category**" >> "$sla_md_file"
            fi
            echo "" >> "$sla_md_file"
          done
          
          # Add footer with additional information
          cat >> "$sla_md_file" << EOM
          
          ---
          
          ## SLA Policy
          
          | Severity | SLA Timeline | Description |
          |----------|--------------|-------------|
          | Critical | 7 days | Immediate security risk |
          | High | 30 days | Significant security risk |
          | Medium | 60 days | Moderate security risk |
          | Low | 90 days | Minor security risk |
          | Unknown | 90 days | Unclassified severity |
          
          ## Notes
          
          - Only vulnerabilities with available fixes are tracked in SLA reports
          - Days remaining calculation is based on published date + SLA timeline
          - Negative values in "Days Remaining" indicate SLA violations
          - Both CVE and GHSA vulnerabilities are included in tracking
          
          ## Action Items
          
          1. **BLACK LIST**: Immediate remediation required - SLA already exceeded
          2. **RED LIST**: Urgent action needed within 1-7 days
          3. **ORANGE LIST**: Plan remediation within 8-21 days  
          4. **YELLOW LIST**: Include in next maintenance cycle
          
          *Report generated automatically by the CVE Scan workflow*
          EOM
          
          echo "‚úÖ SLA markdown report generated: $sla_md_file"
          EOF
          
          chmod +x sla-analysis.sh
          
      - name: Pull images and scan with Grype
        run: |
          release_dir="cve-management/releases/${{ matrix.release }}"
          images_file="$release_dir/images.config"
          results_dir="$release_dir/scan-results"
          
          echo "Starting Grype vulnerability scan for release ${{ matrix.release }}"
          echo "========================================================"
          
          # Initialize consolidated scan report
          echo "# Vulnerability Scan Results for ${{ matrix.release }}" > "$results_dir/scan-grype.md"
          echo "" >> "$results_dir/scan-grype.md"
          echo "**Scan Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$results_dir/scan-grype.md"
          echo "**Release:** ${{ matrix.release }}" >> "$results_dir/scan-grype.md"
          echo "**Scanner:** Grype vulnerability scanner" >> "$results_dir/scan-grype.md"
          echo "**Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> "$results_dir/scan-grype.md"
          echo "" >> "$results_dir/scan-grype.md"
          
          # Initialize consolidated JSON structure
          echo "{" > "$results_dir/scan-grype.json"
          echo "  \"scanInfo\": {" >> "$results_dir/scan-grype.json"
          echo "    \"scanDate\": \"$(date -u '+%Y-%m-%d %H:%M:%S UTC')\"," >> "$results_dir/scan-grype.json"
          echo "    \"release\": \"${{ matrix.release }}\"," >> "$results_dir/scan-grype.json"
          echo "    \"scanner\": \"Grype\"," >> "$results_dir/scan-grype.json"
          echo "    \"workflowRun\": \"${{ github.run_id }}\"" >> "$results_dir/scan-grype.json"
          echo "  }," >> "$results_dir/scan-grype.json"
          echo "  \"images\": [" >> "$results_dir/scan-grype.json"
          
          overall_success=true
          image_count=0
          
          # Add markdown table header (summary will be populated after processing)
          echo "| Image | Status | Vulnerabilities |" >> "$results_dir/scan-grype.md"
          echo "|-------|--------|----------------|" >> "$results_dir/scan-grype.md"
          
          # Create temporary file to collect summary table rows
          summary_table_temp=$(mktemp)
          
          # Process each image
          while IFS= read -r full_image; do
            # Skip empty lines and comments
            [[ -z "$full_image" || "$full_image" =~ ^[[:space:]]*# ]] && continue
            
            # Add comma for JSON array (except for first item)
            [ $image_count -gt 0 ] && echo "," >> "$results_dir/scan-grype.json"
            
            echo ""
            echo "Processing: $full_image"
            echo "----------------------------------------"
            
            # Check if image exists and is accessible
            echo "Checking image accessibility: $full_image"
            max_retries=3
            retry_count=0
            image_accessible=false
            
            while [ $retry_count -lt $max_retries ] && [ "$image_accessible" = false ]; do
              if docker manifest inspect "$full_image" >/dev/null 2>&1; then
                image_accessible=true
                echo "‚úÖ Image $full_image is accessible"
              else
                retry_count=$((retry_count + 1))
                echo "‚ö†Ô∏è Image $full_image not accessible (attempt $retry_count/$max_retries)"
                [ $retry_count -lt $max_retries ] && sleep 2
              fi
            done
            
            if [ "$image_accessible" = true ]; then
              # Scan with Grype - Table and JSON formats  
              echo "Scanning with Grype (Template and JSON formats): $full_image"
              temp_template=$(mktemp)
              temp_json=$(mktemp)
              
              # Create simple template for reliable data extraction (post-process in shell)
              echo 'NAME,INSTALLED,FIXED_IN,TYPE,VULNERABILITY,SEVERITY,EPSS_RAW,RISK,PUBLISHED_DATE' > grype-custom.tmpl
              echo '{{range .Matches}}' >> grype-custom.tmpl
              echo '"{{.Artifact.Name}}","{{.Artifact.Version}}","{{- if .Vulnerability.Fix.Versions }}{{index .Vulnerability.Fix.Versions 0}}{{- end }}","{{.Artifact.Type}}","{{.Vulnerability.ID}}","{{.Vulnerability.Severity}}","{{- if .Vulnerability.EPSS }}{{- if gt (len .Vulnerability.EPSS) 0 }}{{(index .Vulnerability.EPSS 0).Percentile}}{{- else }}0{{- end }}{{- else }}0{{- end }}","{{- if .Vulnerability.Risk }}{{.Vulnerability.Risk}}{{- else }}0{{- end }}","{{.Vulnerability.ID}}"' >> grype-custom.tmpl
              echo '{{end}}' >> grype-custom.tmpl
              
              if grype "$full_image" --output template -t grype-custom.tmpl --file "$temp_template" && \
                 grype "$full_image" --output json --file "$temp_json"; then
                
                echo "‚úÖ Successfully scanned: $full_image"
                
                # Count vulnerabilities from table output - count actual vulnerability lines
                # Count vulnerabilities from JSON instead of table
                if [ -f "$temp_json" ]; then
                  vuln_count=$(jq '.matches | length' "$temp_json" 2>/dev/null || echo "0")
                else
                  vuln_count=0
                fi
                
                # Parse template CSV output for enhanced vulnerability data
                vuln_json_temp=$(mktemp)
                
                if [ -f "$temp_template" ] && [ "$vuln_count" -gt 0 ]; then
                  echo "‚úÖ Converting $vuln_count vulnerabilities from template CSV to JSON for $full_image"
                  
                  # Convert CSV template output to JSON format
                  echo "        \"vulnerabilities\": [" > "$vuln_json_temp"
                  
                  # Skip CSV header and process data lines
                  first_vuln=true
                  while IFS=',' read -r name installed fixed_in type vulnerability severity epss_raw risk published_date; do
                    # Skip the header line
                    [ "$name" = "NAME" ] && continue
                    
                    # Clean up quoted values
                    name=$(echo "$name" | sed 's/^"//; s/"$//')
                    installed=$(echo "$installed" | sed 's/^"//; s/"$//')
                    fixed_in=$(echo "$fixed_in" | sed 's/^"//; s/"$//')
                    type=$(echo "$type" | sed 's/^"//; s/"$//')
                    vulnerability=$(echo "$vulnerability" | sed 's/^"//; s/"$//')
                    severity=$(echo "$severity" | sed 's/^"//; s/"$//')
                    epss_raw=$(echo "$epss_raw" | sed 's/^"//; s/"$//')
                    risk=$(echo "$risk" | sed 's/^"//; s/"$//')
                    published_date=$(echo "$published_date" | sed 's/^"//; s/"$//')
                    
                    # Calculate EPSS percentage (multiply by 100)
                    if [ "$epss_raw" != "0" ] && [ "$epss_raw" != "N/A" ]; then
                      epss=$(echo "$epss_raw * 100" | bc -l | xargs printf "%.1f")%
                    else
                      epss="N/A"
                    fi
                    
                    # Fetch actual published date from APIs for SLA management
                    if [[ "$vulnerability" == CVE-* ]]; then
                      echo "üîç Fetching published date for $vulnerability"
                      # Small delay to avoid API rate limiting
                      sleep 0.5
                      # Query NVD API for CVE published date
                      cve_response=$(curl -s "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=$vulnerability" || echo "")
                      if [ -n "$cve_response" ]; then
                        published_iso=$(echo "$cve_response" | jq -r '.vulnerabilities[0].cve.published // "null"' 2>/dev/null || echo "null")
                        if [ "$published_iso" != "null" ] && [ -n "$published_iso" ]; then
                          # Convert ISO date to YYYY-MM-DD (simplified without days calculation)
                          published_date=$(echo "$published_iso" | cut -d'T' -f1)
                        else
                          published_date="CVE (date unavailable)"
                        fi
                      else
                        published_date="CVE (API error)"
                      fi
                      
                    elif [[ "$vulnerability" == GHSA-* ]]; then
                      echo "üîç Fetching published date for $vulnerability"
                      # Small delay to avoid API rate limiting
                      sleep 0.5
                      # Query GitHub API for GHSA published date
                      ghsa_response=$(curl -s "https://api.github.com/advisories/$vulnerability" || echo "")
                      if [ -n "$ghsa_response" ]; then
                        # Use grep/cut for safer extraction due to potential control characters in JSON
                        published_iso=$(echo "$ghsa_response" | grep '"published_at"' | cut -d'"' -f4 || echo "null")
                        if [ "$published_iso" != "null" ] && [ -n "$published_iso" ]; then
                          # Convert ISO date to YYYY-MM-DD (simplified without days calculation)
                          published_date=$(echo "$published_iso" | cut -d'T' -f1)
                        else
                          published_date="GHSA (date unavailable)"
                        fi
                      else
                        published_date="GHSA (API error)"
                      fi
                      
                    else
                      published_date="N/A"
                    fi
                    
                    # Add comma for previous entry (except first)
                    if [ "$first_vuln" = false ]; then
                      echo "," >> "$vuln_json_temp"
                    fi
                    first_vuln=false
                    
                    # Add vulnerability entry
                    echo "          {" >> "$vuln_json_temp"
                    echo "            \"name\": \"$name\"," >> "$vuln_json_temp"
                    echo "            \"installed\": \"$installed\"," >> "$vuln_json_temp"
                    echo "            \"fixed_in\": \"$fixed_in\"," >> "$vuln_json_temp"
                    echo "            \"type\": \"$type\"," >> "$vuln_json_temp"
                    echo "            \"vulnerability\": \"$vulnerability\"," >> "$vuln_json_temp"
                    echo "            \"severity\": \"$severity\"," >> "$vuln_json_temp"
                    echo "            \"epss\": \"$epss\"," >> "$vuln_json_temp"
                    echo "            \"risk\": \"$risk\"," >> "$vuln_json_temp"
                    echo "            \"published_date\": \"$published_date\"" >> "$vuln_json_temp"
                    echo "          }" >> "$vuln_json_temp"
                  done < "$temp_template"
                  
                  echo "        ]" >> "$vuln_json_temp"
                  echo "‚úÖ Successfully converted template data to JSON"
                else
                  echo "        \"vulnerabilities\": []" > "$vuln_json_temp"
                  echo "‚ö†Ô∏è  No template file or no vulnerabilities found for $full_image"
                fi
                
                # Add to consolidated JSON (add image entry)
                echo "    {" >> "$results_dir/scan-grype.json"
                echo "      \"image\": \"$full_image\"," >> "$results_dir/scan-grype.json"
                echo "      \"status\": \"success\"," >> "$results_dir/scan-grype.json"
                echo "      \"vulnerabilityCount\": $vuln_count," >> "$results_dir/scan-grype.json"
                echo "      \"scan\": {" >> "$results_dir/scan-grype.json"
                cat "$vuln_json_temp" >> "$results_dir/scan-grype.json"
                echo "      }" >> "$results_dir/scan-grype.json"
                echo "    }" >> "$results_dir/scan-grype.json"
                
                # Cleanup temp files
                rm -f "$vuln_json_temp"
                
                # Add to consolidated Markdown
                echo "" >> "$results_dir/scan-grype.md"
                echo "## $full_image" >> "$results_dir/scan-grype.md"
                echo "" >> "$results_dir/scan-grype.md"
                echo "**Vulnerabilities Found:** $vuln_count" >> "$results_dir/scan-grype.md"
                echo "" >> "$results_dir/scan-grype.md"
                
                # Add vulnerability table using template CSV data
                if [ -f "$temp_template" ] && [ "$vuln_count" -gt 0 ]; then
                  echo "### Vulnerability Details" >> "$results_dir/scan-grype.md"
                  echo "" >> "$results_dir/scan-grype.md"
                  
                  # Create markdown table from CSV template data
                  echo "| NAME | INSTALLED | FIXED IN | TYPE | VULNERABILITY | SEVERITY | PUBLISHED DATE |" >> "$results_dir/scan-grype.md"
                  echo "|------|-----------|----------|------|---------------|----------|----------------|" >> "$results_dir/scan-grype.md"
                  
                  # Convert CSV to markdown table (skip header) with post-processing
                  tail -n +2 "$temp_template" | while IFS=',' read -r name installed fixed_in type vulnerability severity epss_raw risk published_date; do
                    # Clean up quoted values
                    name=$(echo "$name" | sed 's/^"//; s/"$//')
                    installed=$(echo "$installed" | sed 's/^"//; s/"$//')
                    fixed_in=$(echo "$fixed_in" | sed 's/^"//; s/"$//')
                    type=$(echo "$type" | sed 's/^"//; s/"$//')
                    vulnerability=$(echo "$vulnerability" | sed 's/^"//; s/"$//')
                    severity=$(echo "$severity" | sed 's/^"//; s/"$//')
                    epss_raw=$(echo "$epss_raw" | sed 's/^"//; s/"$//')
                    published_date=$(echo "$published_date" | sed 's/^"//; s/"$//')
                    
                    # Fetch actual published date from APIs for SLA management (same as JSON processing)
                    if [[ "$vulnerability" == CVE-* ]]; then
                      cve_response=$(curl -s "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=$vulnerability" || echo "")
                      if [ -n "$cve_response" ]; then
                        published_iso=$(echo "$cve_response" | jq -r '.vulnerabilities[0].cve.published // "null"' 2>/dev/null || echo "null")
                        if [ "$published_iso" != "null" ] && [ -n "$published_iso" ]; then
                          published_date=$(echo "$published_iso" | cut -d'T' -f1)
                          days_since=$(( ($(date +%s) - $(date -d "$published_date" +%s)) / 86400 ))
                          published_date="$published_date ($days_since days ago)"
                        else
                          published_date="CVE (date unavailable)"
                        fi
                      else
                        published_date="CVE (API error)"
                      fi
                      
                    elif [[ "$vulnerability" == GHSA-* ]]; then
                      ghsa_response=$(curl -s "https://api.github.com/advisories/$vulnerability" || echo "")
                      if [ -n "$ghsa_response" ]; then
                        # Use grep/cut for safer extraction due to potential control characters in JSON
                        published_iso=$(echo "$ghsa_response" | grep '"published_at"' | cut -d'"' -f4 || echo "null")
                        if [ "$published_iso" != "null" ] && [ -n "$published_iso" ]; then
                          published_date=$(echo "$published_iso" | cut -d'T' -f1)
                          days_since=$(( ($(date +%s) - $(date -d "$published_date" +%s)) / 86400 ))
                          published_date="$published_date ($days_since days ago)"
                        else
                          published_date="GHSA (date unavailable)"
                        fi
                      else
                        published_date="GHSA (API error)"
                      fi
                      
                    else
                      published_date="N/A"
                    fi
                    
                    echo "| $name | $installed | $fixed_in | $type | $vulnerability | $severity | $published_date |" >> "$results_dir/scan-grype.md"
                  done
                  
                  echo "" >> "$results_dir/scan-grype.md"
                  echo "‚úÖ Generated markdown table from template data for $vuln_count vulnerabilities"
                fi
                
                # Add to summary table (collect in temp file for proper placement)
                vuln_display="$vuln_count vulnerabilities"
                [ "$vuln_count" = "0" ] && vuln_display="‚úÖ No vulnerabilities"
                
                echo "| \`$full_image\` | ‚úÖ Success | $vuln_display |" >> "$summary_table_temp"
                
                # Cleanup temp files
                rm -f "$temp_template" "$temp_json" "grype-custom.tmpl"
                
              else
                echo "‚ùå Failed to scan: $full_image"
                
                # Add failed entry to JSON
                echo "    {" >> "$results_dir/scan-grype.json"
                echo "      \"image\": \"$full_image\"," >> "$results_dir/scan-grype.json"
                echo "      \"status\": \"scan_failed\"," >> "$results_dir/scan-grype.json"
                echo "      \"vulnerabilityCount\": null," >> "$results_dir/scan-grype.json"
                echo "      \"scan\": null" >> "$results_dir/scan-grype.json"
                echo "    }" >> "$results_dir/scan-grype.json"
                
                echo "| \`$full_image\` | ‚ùå Scan Failed | Error during scan |" >> "$results_dir/scan-grype.md"
                overall_success=false
                rm -f "$temp_table" "$temp_json"
              fi
              
            else
              echo "‚ùå Cannot access image: $full_image"
              
              # Add failed entry to JSON
              echo "    {" >> "$results_dir/scan-grype.json"
              echo "      \"image\": \"$full_image\"," >> "$results_dir/scan-grype.json"
              echo "      \"status\": \"access_failed\"," >> "$results_dir/scan-grype.json"
              echo "      \"vulnerabilityCount\": null," >> "$results_dir/scan-grype.json"
              echo "      \"scan\": null" >> "$results_dir/scan-grype.json"
              echo "    }" >> "$results_dir/scan-grype.json"
              
              echo "| \`$full_image\` | ‚ùå Access Failed | Image not accessible |" >> "$summary_table_temp"
              overall_success=false
            fi
            
            image_count=$((image_count + 1))
            
          done < "$images_file"
          
          # Insert summary table rows at the correct location (after table header, before image sections)
          if [ -f "$summary_table_temp" ] && [ -s "$summary_table_temp" ]; then
            # Create temporary markdown file to reorganize content
            markdown_temp=$(mktemp)
            
            # Copy everything up to and including the table header
            head -n $(grep -n "|-------|" "$results_dir/scan-grype.md" | cut -d: -f1) "$results_dir/scan-grype.md" > "$markdown_temp"
            
            # Add the summary table rows
            cat "$summary_table_temp" >> "$markdown_temp"
            
            # Add the rest of the content (image sections)
            tail -n +$(( $(grep -n "|-------|" "$results_dir/scan-grype.md" | cut -d: -f1) + 1 )) "$results_dir/scan-grype.md" >> "$markdown_temp"
            
            # Replace the original file
            mv "$markdown_temp" "$results_dir/scan-grype.md"
            
            # Cleanup summary table temp file
            rm -f "$summary_table_temp"
          fi
          
          # Close JSON structure
          echo "" >> "$results_dir/scan-grype.json"
          echo "  ]" >> "$results_dir/scan-grype.json"
          echo "}" >> "$results_dir/scan-grype.json"
          
          echo ""
          echo "========================================================"
          echo "Grype vulnerability scan completed for release ${{ matrix.release }}"
          
      - name: Generate SLA Report
        run: |
          ./sla-analysis.sh "cve-management/releases/${{ matrix.release }}/scan-results" "${{ matrix.release }}" "${{ github.run_id }}"
          
      - name: Add scan metadata
        run: |
          results_dir="cve-management/releases/${{ matrix.release }}/scan-results"
          image_count=$(find cve-management/releases/${{ matrix.release }}/scan-results -name "*.json" | wc -l)
          
          # Add scan metadata to consolidated report
          echo "" >> "$results_dir/scan-grype.md"
          echo "## Scan Information" >> "$results_dir/scan-grype.md"
          echo "- **Total Images**: $image_count" >> "$results_dir/scan-grype.md"
          echo "- **Scan Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$results_dir/scan-grype.md"
          echo "- **Workflow**: ${{ github.workflow }}" >> "$results_dir/scan-grype.md"
          echo "- **Run ID**: ${{ github.run_id }}" >> "$results_dir/scan-grype.md"
          echo "- **Overall Status**: ‚úÖ Scan completed successfully" >> "$results_dir/scan-grype.md"
          
          # Output the summary
          echo ""
          echo "Consolidated scan results for ${{ matrix.release }}:"
          echo "- JSON: $results_dir/scan-grype.json"
          echo "- Markdown: $results_dir/scan-grype.md"
          
      - name: Commit scan results to release folder
        run: |
          release_dir="cve-management/releases/${{ matrix.release }}"
          
          # Configure git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Check if consolidated files exist and have content
          if [ -f "$release_dir/scan-results/scan-grype.json" ] && [ -f "$release_dir/scan-results/scan-grype.md" ]; then
            echo "Consolidated scan result files generated, proceeding with commit"
            # Add and commit the scan results
            git add "$release_dir/scan-results/"
            git commit -m "Update vulnerability scan results for ${{ matrix.release }} - Grype consolidated scan: $(date -u '+%Y-%m-%d %H:%M:%S UTC') - Run: ${{ github.run_id }}"
            
            echo "‚úÖ Committed consolidated scan results for ${{ matrix.release }}"
          else
            echo "‚ùå Consolidated scan result files not found, skipping commit"
            echo "Expected files:"
            echo "  - $release_dir/scan-results/scan-grype.json"
            echo "  - $release_dir/scan-results/scan-grype.md"
            ls -la "$release_dir/scan-results/" || echo "Scan results directory not found"
          fi
          
      - name: Push scan results to repository
        run: |
          # Check if there are any commits to push
          if git log --oneline origin/main..HEAD | grep -q "Update vulnerability scan results"; then
            echo "Pushing scan results to repository..."
            
            # Retry push with pull/rebase in case of concurrent pushes
            max_retries=5
            retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              if git push origin main; then
                echo "‚úÖ Successfully pushed scan results for ${{ matrix.release }} (attempt $((retry_count + 1)))"
                break
              else
                retry_count=$((retry_count + 1))
                if [ $retry_count -lt $max_retries ]; then
                  echo "‚ö†Ô∏è Push failed, attempting to pull and rebase (attempt $retry_count/$max_retries)..."
                  
                  # Pull with rebase to integrate remote changes
                  if git pull --rebase origin main; then
                    echo "‚úÖ Successfully rebased with remote changes"
                    # Add a small random delay to reduce race conditions
                    sleep $((RANDOM % 10 + 1))
                  else
                    echo "‚ùå Failed to rebase with remote changes"
                    break
                  fi
                else
                  echo "‚ùå Failed to push after $max_retries attempts for ${{ matrix.release }}"
                  echo "This is likely due to concurrent job conflicts, but scan results are still generated as artifacts"
                  exit 1
                fi
              fi
            done
          else
            echo "No CVE scan result commits to push"
          fi
          
      - name: Upload scan results as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vulnerability-scan-${{ matrix.release }}
          path: cve-management/releases/${{ matrix.release }}/scan-results/
          retention-days: 30

  summary:
    runs-on: ubuntu-latest
    needs: [discover-releases, cve-scan]
    if: always() && needs.discover-releases.outputs.releases != '[]'
    steps:
      - name: Download all scan results
        uses: actions/download-artifact@v4
        with:
          path: all-scan-results/
          pattern: vulnerability-scan-*
          
      - name: Generate overall summary
        run: |
          echo "# Overall Vulnerability Scan Summary" > overall-summary.md
          echo "" >> overall-summary.md
          echo "**Scan Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> overall-summary.md
          echo "**Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> overall-summary.md
          echo "" >> overall-summary.md
          
          # Find all consolidated markdown files
          find all-scan-results -name "scan-grype.md" | while read -r scan_file; do
            release_name=$(echo "$scan_file" | sed 's|all-scan-results/vulnerability-scan-||' | sed 's|/scan-grype.md||')
            echo "## Release: $release_name" >> overall-summary.md
            echo "" >> overall-summary.md
            # Skip the first line (title) of each summary
            tail -n +2 "$scan_file" >> overall-summary.md
            echo "" >> overall-summary.md
          done
          
          echo "Generated overall summary:"
          cat overall-summary.md
          
      - name: Upload overall summary
        uses: actions/upload-artifact@v4
        with:
          name: vulnerability-scan-summary
          path: overall-summary.md
          retention-days: 30
